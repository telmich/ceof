1) how an onion is created

create route
create chain with commands, list append, first element is last receiver:
    [ peer1, peer2, peer3 ]

    peer1 is the last one to receive, peer3 is the first one

create onion
    pop() from list:
    1) peer3:
        2) peer2
            3) peer1:

2) the forward command within an onion
    peers = [ peer1, peer2, peer3 ]

- needs to know where to send to

    peer3 needs to forward to peer2
    peer2 needs to forward to peer1
    add address during chaining from previous peer

3) send multiple times over one peer?

128     @classmethod
129     def list_random_peers(cls, base_dir, num_peers, notthispeer=None):
130         peers = cls.list_peers(base_dir)
131         random_peers = []
132 
133         # FIXME: can one packet travel more than one time through one node?
134         # FIXME: 
135         if len(peers) < num_peers:

decided against, because it may retravel a compromised peer.


4) enhance to trnaspont arbitraty data

- remove chat / tag message with content:chat 
- add new tag: data
- add data handler

5) finding peers - #1

- directory service
- keyserver
- special keys
- address can be used for initial contact
    EOF42KEY

- reply with all my addresses
- how to verify the addresses belong to this peer?

6) finding peers - #2

- request random peer [addresses] from known peer
- how to verify the addresses belong to this peer?
    - from trusted peers only?

7) replay attacks

what happens? 
how to prevent?

8) acknowledge packets

how?
tcp - not
rudp

9) could not decrypt packet

send to next-next peer, not to next
address (of peer) vs forward_address of packet for peer
